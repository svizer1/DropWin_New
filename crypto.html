<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>–ê–∫—Ü–∏–∏: –ö—Ä–∏–ø—Ç–∞ | DropWin</title>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    .crypto-item {
      background: rgba(30,27,71,0.7);
      border-radius: 16px;
      padding: 18px;
      margin-bottom: 18px;
      border: 1px solid rgba(139,92,246,0.35);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: all 0.25s ease;
    }
    .crypto-item:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 12px 30px rgba(192,132,252,0.35);
      border-color: #c084fc;
    }
    .crypto-name {
      font-size: 1.4rem;
      font-weight: 800;
      color: #c084fc;
      margin-bottom: 6px;
    }
    .crypto-price {
      font-size: 1.7rem;
      font-weight: 700;
      margin-bottom: 8px;
    }
    .price-change {
      font-size: 1.1rem;
      font-weight: 600;
      margin-left: 12px;
    }
    .change-up   { color: #34d399; }
    .change-down { color: #f87171; }
    .portfolio-info {
      font-size: 1rem;
      color: #94a3b8;
      margin: 8px 0 12px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }
    .controls input {
      flex: 1 1 110px;
      padding: 10px 12px;
      font-size: 1rem;
      border-radius: 10px;
      border: 1px solid #4b5563;
      background: rgba(255,255,255,0.05);
      color: white;
    }
    .controls button {
      padding: 10px 18px;
      font-size: 0.95rem;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .buy-btn      { background: #10b981; color: white; }
    .sell-btn     { background: #ef4444; color: white; }
    .sell-all-btn { background: #991b1b; color: white; flex: 1 1 100%; }
    .all-btn      { background: #6366f1; color: white; flex: 1 1 100%; }
    .buy-btn:hover, .sell-btn:hover, .sell-all-btn:hover, .all-btn:hover {
      filter: brightness(1.15);
      transform: translateY(-2px);
    }
    .cooldown-msg {
      color: #fbbf24;
      font-size: 0.9rem;
      margin-top: 6px;
      font-weight: 600;
    }
    .popular-badge {
      font-size: 0.9rem;
      background: #fbbf24;
      color: #1e1b47;
      padding: 2px 8px;
      border-radius: 12px;
      margin-left: 8px;
      font-weight: 700;
    }
    .new-exclusive {
      font-size: 0.9rem;
      background: #34d399;
      color: #1e1b47;
      padding: 2px 8px;
      border-radius: 12px;
      margin-left: 8px;
      font-weight: 700;
    }
    .expired-msg {
      color: #f87171;
      font-size: 0.9rem;
      margin-top: 6px;
      font-weight: 600;
    }
    .profit { color: #34d399; }
    .loss { color: #f87171; }
  </style>
</head>
<body>
<div class="particles" id="particles"></div>

<div class="header">
  <div class="logo" onclick="location.href='index.html'" style="cursor: pointer;">üíé DROPWIN</div>
  <div class="balance-container">
    <div class="balance">üí∞ <span id="balance">0</span>‚ÇΩ</div>
    <button class="auth-btn" id="authBtn">–ê–∫–∫–∞—É–Ω—Ç</button>
  </div>
</div>

<div class="content">
  <button class="back-btn" onclick="location.href='index.html'">‚Üê –ù–∞–∑–∞–¥</button>

  <div class="game-card">
    <div class="game-title">üìà –ê–∫—Ü–∏–∏: –ö—Ä–∏–ø—Ç–∞</div>
    <div id="crypto-list"></div>
  </div>
</div>

<div class="nav">
  <button class="nav-btn" onclick="location.href='index.html'"><span>üè†</span><span class="nav-label">–ì–ª–∞–≤–Ω–∞—è</span></button>
  <button class="nav-btn" onclick="location.href='profile.html'"><span>üë§</span><span class="nav-label">–ü—Ä–æ—Ñ–∏–ª—å</span></button>
  <button class="nav-btn" onclick="location.href='register.html'"><span>üîë</span><span class="nav-label">–í—Ö–æ–¥</span></button>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
  import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
  import { getFirestore, doc, getDoc, updateDoc, onSnapshot, setDoc, arrayUnion, serverTimestamp, increment } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyBVra2JN-C7-1b_Qa4cU8--XvJ83lymiM8",
    authDomain: "dropwin-8d94b.firebaseapp.com",
    projectId: "dropwin-8d94b",
    storageBucket: "dropwin-8d94b.firebasestorage.app",
    messagingSenderId: "988974289403",
    appId: "1:988974289403:web:886d34e6f65920a105fb5e",
    measurementId: "G-BK010MHN8N"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  function createParticles() {
    const container = document.getElementById('particles');
    if (!container) return;
    for (let i = 0; i < 40; i++) {
      const p = document.createElement('div');
      p.className = 'particle';
      p.style.width = p.style.height = Math.random() * 3 + 1 + 'px';
      p.style.left = Math.random() * 100 + '%';
      p.style.animationDuration = Math.random() * 15 + 10 + 's';
      p.style.animationDelay = Math.random() * 5 + 's';
      container.appendChild(p);
    }
  }

  let currentUser = null;
  let userId = null;
  let portfolio = {};
  const PRICE_DRIFT_INTERVAL_MS = 30000;

  const coins = [
    { id: 'wincoin',      name: 'WinCoin',      startPrice: 1.00     },
    { id: 'tgcoin',       name: 'TgCoin',       startPrice: 15.00    },
    { id: 'bomjcoin',     name: 'BomjCoin',     startPrice: 0.01     },
    { id: 'milionercoin', name: 'MilionerCoin', startPrice: 50.00    },
    { id: 'crashcoin',    name: 'CrashCoin',    startPrice: 100.00   },
    { id: 'dropwincoin',  name: 'DropWinCoin',  startPrice: 75.00    },
    { id: 'limosycoin',   name: 'LimosyCoin',   startPrice: 15.00    }
  ];

  const prices = {};
  const histories = {};
  const prevPrices = {};
  const volumes = {};
  const creationTimes = {};
  const lastUpdates = {};

  const cryptoElements = {};
  const cryptoCharts = {};

  onAuthStateChanged(auth, async (user) => {
    if (user) {
      userId = user.uid;
      const userDoc = await getDoc(doc(db, 'users', user.uid));
      if (userDoc.exists()) {
        currentUser = userDoc.data();
        portfolio = currentUser.cryptoPortfolio || {};
        document.getElementById('balance').textContent = Math.round(currentUser.balance || 0);
        renderList();
      }
    } else {
      location.href = 'register.html';
    }
  });

  async function initPrices() {
    for (const coin of coins) {
      const ref = doc(db, 'cryptoPrices', coin.id);
      const snap = await getDoc(ref);
      if (!snap.exists()) {
        const data = {
          price: coin.startPrice,
          history: [coin.startPrice],
          volume: 0,
          lastUpdate: serverTimestamp()
        };
        if (coin.id === 'limosycoin') {
          data.creationTime = serverTimestamp();
        }
        await setDoc(ref, data);
      }
    }
  }

  async function catchUpCryptoPrices() {
    for (const coin of coins) {
      const ref = doc(db, 'cryptoPrices', coin.id);
      const snap = await getDoc(ref);
      if (!snap.exists()) continue;
      let data = snap.data();
      let price = data.price;
      let history = Array.isArray(data.history) ? data.history.slice() : [data.price];
      let volume = data.volume || 0;
      let last = data.lastUpdate?.toMillis ? data.lastUpdate.toMillis() : Date.now();
      const now = Date.now();
      let steps = Math.floor((now - last) / PRICE_DRIFT_INTERVAL_MS);
      if (steps <= 0) continue;
      steps = Math.min(steps, 120);
      for (let i = 0; i < steps; i++) {
        const change = (Math.random() * 0.03 - 0.015);
        price *= (1 + change);
        price = Math.max(price, 0.00001);
        history.push(price);
        if (history.length > 60) history.shift();
        const isBuy = Math.random() > 0.5;
        const impact = Math.random() * 0.002 + 0.001;
        price *= isBuy ? (1 + impact) : (1 - impact);
        volume += Math.random() * 500 + 100;
      }
      await updateDoc(ref, { price, history, volume, lastUpdate: serverTimestamp() });
    }
  }

  coins.forEach(coin => {
    onSnapshot(doc(db, 'cryptoPrices', coin.id), (snap) => {
      if (snap.exists()) {
        const data = snap.data();
        prevPrices[coin.id] = prices[coin.id] || data.price;
        prices[coin.id] = data.price;
        histories[coin.id] = data.history || [data.price];
        volumes[coin.id] = data.volume || 0;
        if (data.creationTime?.toMillis) {
          creationTimes[coin.id] = data.creationTime.toMillis();
        }
        if (data.lastUpdate?.toMillis) {
          lastUpdates[coin.id] = data.lastUpdate.toMillis();
        }
        renderList();
      }
    });
  });

  // –£–≤–µ–ª–∏—á–∏–ª–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏
  setInterval(async () => {
    for (const coin of coins) {
      const ref = doc(db, 'cryptoPrices', coin.id);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        let { price, history = [], volume } = snap.data();
        const change = (Math.random() * 0.03 - 0.015); // –ú–µ–Ω—å—à–µ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞
        price *= (1 + change);
        price = Math.max(price, 0.00001);

        history.push(price);
        if (history.length > 60) history.shift();

        await updateDoc(ref, { price, history, lastUpdate: serverTimestamp() });
      }
    }
  }, 30000); // –î–æ–ª—å—à–µ: –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫ –≤–º–µ—Å—Ç–æ 20

  // –£–≤–µ–ª–∏—á–∏–ª–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è –±–æ—Ç–æ–≤
  setInterval(async () => {
    for (let i = 0; i < 2; i++) { // –î–≤–∞ –±–æ—Ç–∞ –∑–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª –¥–ª—è "–ø–æ–±–æ–ª—å—à–µ"
      const coin = coins[Math.floor(Math.random() * coins.length)];
      const ref = doc(db, 'cryptoPrices', coin.id);
      const snap = await getDoc(ref);
      if (snap.exists()) {
        let { price, volume = 0 } = snap.data();
        const isBuy = Math.random() > 0.5;
        const impact = Math.random() * 0.002 + 0.001; // –ú–µ–Ω—å—à–µ –≤–ª–∏—è–Ω–∏–µ –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞
        price *= isBuy ? (1 + impact) : (1 - impact);
        volume += Math.random() * 500 + 100; // –ú–µ–Ω—å—à–µ –æ–±—ä–µ–º—ã –¥–ª—è –±–∞–ª–∞–Ω—Å–∞
        await updateDoc(ref, { price, volume, lastUpdate: serverTimestamp() });
      }
    }
  }, 90000); // –î–æ–ª—å—à–µ: 90 —Å–µ–∫ –≤–º–µ—Å—Ç–æ 60

  window.buy = async function(coinId) {
    if (!currentUser) return;
    const rubInput = document.getElementById(`${coinId}-rub`);
    const amtInput = document.getElementById(`${coinId}-amt`);
    const price = prices[coinId];
    let amount = parseFloat(amtInput.value) || 0;
    let rub = parseFloat(rubInput.value) || 0;

    if (rub > 0 && price) {
      amount = rub / price;
      amtInput.value = amount.toFixed(6);
    } else if (amount > 0 && price) {
      rub = amount * price;
      rubInput.value = Math.round(rub);
    }

    if (amount <= 0) return;
    const cost = Math.round(amount * price);
    if (cost > currentUser.balance) {
      alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤');
      return;
    }

    if (coinId === 'limosycoin') {
      const creationTime = creationTimes[coinId];
      if (creationTime && Date.now() - creationTime > 5 * 24 * 60 * 60 * 1000) {
        alert('–ü–æ–∫—É–ø–∫–∞ LimosyCoin –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞! –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏—Å—Ç–µ–∫.');
        return;
      }
    }

    currentUser.balance -= cost;

    if (!portfolio[coinId]) portfolio[coinId] = { amount: 0, avgPrice: 0, invested: 0, lastBuyTime: 0 };
    const old = portfolio[coinId];
    const newAmount = old.amount + amount;
    const newInvested = old.invested + cost;
    const newAvg = newAmount > 0 ? newInvested / newAmount : 0;

    portfolio[coinId] = { amount: newAmount, avgPrice: newAvg, invested: newInvested, lastBuyTime: Date.now() };

    // –£–º–µ–Ω—å—à–∏–ª–∏ priceImpact –¥–ª—è –º–µ–Ω—å—à–µ–≥–æ –ø–æ–≤—ã—à–µ–Ω–∏—è —Ü–µ–Ω—ã
    const priceImpact = Math.min(0.001 * (cost / price), 0.005); // –ú–µ–Ω—å—à–µ: 0.1% –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É, max 0.5%
    const newPrice = prices[coinId] * (1 + priceImpact);
    const newVolume = (volumes[coinId] || 0) + cost;

    await updateDoc(doc(db, 'cryptoPrices', coinId), { price: newPrice, volume: newVolume, lastUpdate: serverTimestamp() });

    const transaction = {
      timestamp: new Date().toISOString(),
      coin: coinId,
      type: 'buy',
      amount, price, cost
    };

    // 5% –æ—Ç –ø–æ–∫—É–ø–∫–∏ LimosyCoin –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç Limosy, –µ—Å–ª–∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –Ω–µ —Å–∞–º Limosy
    if (coinId === 'limosycoin' && userId !== 'N7uykI0l7sPXyrjYfuWuPHoJ25i2') {
      const fee = 0.05 * cost;
      const limosyUid = 'N7uykI0l7sPXyrjYfuWuPHoJ25i2';
      const feeTransaction = {
        timestamp: new Date().toISOString(),
        coin: coinId,
        type: 'fee_in',
        amount: fee,
        from: currentUser.username || '–ê–Ω–æ–Ω–∏–º',
        originalCost: cost
      };

      try {
        await updateDoc(doc(db, 'users', limosyUid), {
          balance: increment(fee),
          cryptoTransactions: arrayUnion(feeTransaction)
        });
      } catch (e) {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞—á–∏—Å–ª–∏—Ç—å 5% –∫–æ–º–∏—Å—Å–∏–∏ Limosy (–ø—Ä–æ–≤–µ—Ä—å rules):', e);
      }
    }

    await updateDoc(doc(db, 'users', userId), {
      cryptoTransactions: arrayUnion(transaction),
      balance: currentUser.balance,
      cryptoPortfolio: portfolio
    });

    document.getElementById('balance').textContent = Math.round(currentUser.balance);
    renderList();
  };

  window.sell = async function(coinId) {
    if (!portfolio[coinId]) return;
    const rubInput = document.getElementById(`${coinId}-rub`);
    const amtInput = document.getElementById(`${coinId}-amt`);
    const price = prices[coinId];
    let amount = parseFloat(amtInput.value) || 0;
    let rub = parseFloat(rubInput.value) || 0;

    if (rub > 0 && price) {
      amount = rub / price;
      amtInput.value = amount.toFixed(6);
    } else if (amount > 0 && price) {
      rub = amount * price;
      rubInput.value = Math.round(rub);
    }

    if (amount <= 0 || amount > portfolio[coinId].amount) {
      alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç');
      return;
    }

    const lastBuy = portfolio[coinId].lastBuyTime || 0;
    const timeLeft = 5 * 60 * 1000 - (Date.now() - lastBuy);
    if (timeLeft > 0) {
      const minutes = Math.ceil(timeLeft / 60000);
      alert(`–ù–µ–ª—å–∑—è –ø—Ä–æ–¥–∞–≤–∞—Ç—å –º–æ–Ω–µ—Ç—É! –û—Å—Ç–∞–ª–æ—Å—å ${minutes} –º–∏–Ω –ø–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏.`);
      return;
    }

    const revenue = Math.round(amount * price);
    const soldRatio = amount / portfolio[coinId].amount;
    portfolio[coinId].invested -= portfolio[coinId].invested * soldRatio;

    currentUser.balance += revenue;
    portfolio[coinId].amount -= amount;

    if (portfolio[coinId].amount <= 0) delete portfolio[coinId];

    const priceImpact = Math.min(0.001 * (revenue / price), 0.005);
    const newPrice = prices[coinId] * (1 - priceImpact);
    const newVolume = (volumes[coinId] || 0) + revenue;

    await updateDoc(doc(db, 'cryptoPrices', coinId), { price: newPrice, volume: newVolume, lastUpdate: serverTimestamp() });

    const transaction = {
      timestamp: new Date().toISOString(),
      coin: coinId,
      type: 'sell',
      amount, price, revenue
    };

    await updateDoc(doc(db, 'users', userId), {
      cryptoTransactions: arrayUnion(transaction),
      balance: currentUser.balance,
      cryptoPortfolio: portfolio
    });

    document.getElementById('balance').textContent = Math.round(currentUser.balance);
    renderList();
  };

  window.sellAll = async function(coinId) {
    if (!portfolio[coinId] || portfolio[coinId].amount <= 0) {
      alert('–ù–µ—Ç –º–æ–Ω–µ—Ç –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏');
      return;
    }

    const lastBuy = portfolio[coinId].lastBuyTime || 0;
    const timeLeft = 5 * 60 * 1000 - (Date.now() - lastBuy);
    if (timeLeft > 0) {
      const minutes = Math.ceil(timeLeft / 60000);
      alert(`–ù–µ–ª—å–∑—è –ø—Ä–æ–¥–∞–≤–∞—Ç—å –º–æ–Ω–µ—Ç—É! –û—Å—Ç–∞–ª–æ—Å—å ${minutes} –º–∏–Ω –ø–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏.`);
      return;
    }

    const amount = portfolio[coinId].amount;
    document.getElementById(`${coinId}-amt`).value = amount.toFixed(6);
    document.getElementById(`${coinId}-rub`).value = Math.round(amount * prices[coinId]);
    window.sell(coinId);
  };

  window.buyAll = async function(coinId) {
    if (!currentUser || currentUser.balance <= 0) return;

    if (coinId === 'limosycoin') {
      const creationTime = creationTimes[coinId];
      if (creationTime && Date.now() - creationTime > 5 * 24 * 60 * 60 * 1000) {
        alert('–ü–æ–∫—É–ø–∫–∞ LimosyCoin –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞! –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏—Å—Ç–µ–∫.');
        return;
      }
    }

    const amount = currentUser.balance / prices[coinId];
    document.getElementById(`${coinId}-amt`).value = amount.toFixed(6);
    document.getElementById(`${coinId}-rub`).value = Math.round(currentUser.balance);
    window.buy(coinId);
  };

  function timeAgo(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days} –¥–Ω. –Ω–∞–∑–∞–¥`;
    if (hours > 0) return `${hours} —á. –Ω–∞–∑–∞–¥`;
    if (minutes > 0) return `${minutes} –º–∏–Ω. –Ω–∞–∑–∞–¥`;
    return `—Ç–æ–ª—å–∫–æ —á—Ç–æ`;
  }

  function formatPrice(price) {
    if (price >= 1) {
      return price.toFixed(3);
    } else if (price >= 0.001) {
      return price.toFixed(6);
    } else {
      return price.toPrecision(6).replace(/0+$/, '');
    }
  }

  function renderList() {
    const container = document.getElementById('crypto-list');

    let sortedCoins = [...coins];

    const limosyIndex = sortedCoins.findIndex(c => c.id === 'limosycoin');
    const limosy = sortedCoins[limosyIndex];
    const isLimosyActive = limosy && creationTimes['limosycoin'] &&
      (Date.now() - creationTimes['limosycoin'] < 5 * 24 * 60 * 60 * 1000);

    if (isLimosyActive && limosyIndex !== -1) {
      sortedCoins.splice(limosyIndex, 1);
      sortedCoins.unshift(limosy);
    }

    sortedCoins.sort((a, b) => {
      if (a.id === 'limosycoin' && isLimosyActive) return -1;
      if (b.id === 'limosycoin' && isLimosyActive) return 1;
      return (volumes[b.id] || 0) - (volumes[a.id] || 0);
    });

    sortedCoins.forEach((coin, index) => {
      const coinId = coin.id;
      const price = prices[coinId] || coin.startPrice;
      const prev = prevPrices[coinId] || price;
      const changePercent = prev !== 0 ? ((price - prev) / prev * 100) : 0;
      const changeClass = changePercent >= 0 ? 'change-up' : 'change-down';
      const changeText = changePercent >= 0 ? `+${changePercent.toFixed(2)}%` : `${changePercent.toFixed(2)}%`;

      const port = portfolio[coinId] || { amount: 0, avgPrice: 0, invested: 0, lastBuyTime: 0 };
      const currentValue = port.amount * price;
      const profitLoss = currentValue - port.invested;
      const plClass = profitLoss >= 0 ? 'profit' : 'loss';
      const plText = Math.round(profitLoss);

      let hist = histories[coinId] || [price];
      if (!Array.isArray(hist)) hist = [price];

      const cooldown = port.lastBuyTime ? 5 * 60 * 1000 - (Date.now() - port.lastBuyTime) : 0;
      let cooldownHtml = '';
      if (cooldown > 0) {
        const minutes = Math.ceil(cooldown / 60000);
        cooldownHtml = `<div class="cooldown-msg">–ü—Ä–æ–¥–∞–∂–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è —á–µ—Ä–µ–∑ ${minutes} –º–∏–Ω</div>`;
      } else if (cooldown <= 0 && port.lastBuyTime) {
        cooldownHtml = `<div class="cooldown-msg" style="color:#34d399">–ü—Ä–æ–¥–∞–∂–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞!</div>`;
      }

      let badgeHtml = '';

      if (coinId === 'limosycoin') {
        const creationTime = creationTimes[coinId];
        const isExpired = creationTime && Date.now() - creationTime > 5 * 24 * 60 * 60 * 1000;
        if (!isExpired) {
          badgeHtml = `<span class="new-exclusive">NEW –≠–∫—Å–∫–ª—é–∑–∏–≤</span>`;
        }
      }

      const isPopular = index < 3 && badgeHtml === '';
      if (isPopular) {
        badgeHtml = `<span class="popular-badge">üî• –ü–æ–ø—É–ª—è—Ä–Ω—ã–π</span>`;
      }

      const nameHtml = `${coin.name}${badgeHtml}`;

      let expiredHtml = '';
      let buyDisabled = false;
      if (coinId === 'limosycoin') {
        const creationTime = creationTimes[coinId];
        if (creationTime && Date.now() - creationTime > 5 * 24 * 60 * 60 * 1000) {
          expiredHtml = `<div class="expired-msg">–ü–æ–∫—É–ø–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞! –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏—Å—Ç–µ–∫ (5 –¥–Ω–µ–π).</div>`;
          buyDisabled = true;
        }
      }

      const lastUpdateTime = lastUpdates[coinId] || Date.now();
      const timeAgoText = timeAgo(lastUpdateTime);

      if (!cryptoElements[coinId]) {
        const div = document.createElement('div');
        div.className = 'crypto-item';
        div.id = `crypto-${coinId}`;
        div.innerHTML = `
          <div class="crypto-name"></div>
          <div>
            <span class="crypto-price"></span>
            <span class="price-change"></span>
          </div>
          <div class="portfolio-info">
            –£ —Ç–µ–±—è: <span class="port-amount"></span> —à—Ç<br>
            –°—Ä. —Ü–µ–Ω–∞: <span class="port-avg"></span> ‚ÇΩ<br>
            <span class="port-pl"></span>
          </div>
          <div class="cooldown-placeholder"></div>
          <div class="expired-placeholder"></div>

          <div class="controls">
            <input type="number" id="${coinId}-rub" placeholder="–°–∫–æ–ª—å–∫–æ ‚ÇΩ" step="1" min="1">
            <input type="number" id="${coinId}-amt" placeholder="–°–∫–æ–ª—å–∫–æ —à—Ç" step="any" min="0.000001">
            <button class="buy-btn">–ö—É–ø–∏—Ç—å</button>
            <button class="sell-btn">–ü—Ä–æ–¥–∞—Ç—å</button>
            <button class="sell-all-btn">–ü—Ä–æ–¥–∞—Ç—å –≤—Å—ë</button>
            <button class="all-btn">–ö—É–ø–∏—Ç—å –Ω–∞ –≤—Å—ë</button>
          </div>

          <canvas id="chart-${coinId}" height="160"></canvas>
        `;
        container.appendChild(div);

        cryptoElements[coinId] = {
          root: div,
          name: div.querySelector('.crypto-name'),
          price: div.querySelector('.crypto-price'),
          change: div.querySelector('.price-change'),
          portAmount: div.querySelector('.port-amount'),
          portAvg: div.querySelector('.port-avg'),
          portPl: div.querySelector('.port-pl'),
          cooldown: div.querySelector('.cooldown-placeholder'),
          expired: div.querySelector('.expired-placeholder'),
          buyBtn: div.querySelector('.buy-btn'),
          buyAllBtn: div.querySelector('.all-btn'),
          rubInput: div.querySelector(`#${coinId}-rub`),
          amtInput: div.querySelector(`#${coinId}-amt`)
        };

        const { rubInput, amtInput } = cryptoElements[coinId];
        rubInput.oninput = () => {
          const rub = parseFloat(rubInput.value) || 0;
          if (rub > 0 && prices[coinId]) amtInput.value = (rub / prices[coinId]).toFixed(6);
        };
        amtInput.oninput = () => {
          const amt = parseFloat(amtInput.value) || 0;
          if (amt > 0 && prices[coinId]) rubInput.value = Math.round(amt * prices[coinId]);
        };

        const canvas = document.getElementById(`chart-${coinId}`);
        cryptoCharts[coinId] = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: {
            labels: hist.map((_,i)=>i),
            datasets: [{
              label: '–¶–µ–Ω–∞ ‚ÇΩ',
              data: hist,
              borderColor: '#c084fc',
              backgroundColor: 'rgba(192,132,252,0.08)',
              fill: true,
              tension: 0.4,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: { display: false },
              y: {
                ticks: { color: '#94a3b8', font: { size: 11 }, callback: v => formatPrice(v) },
                grid: { color: 'rgba(139,92,246,0.08)' }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return `–¶–µ–Ω–∞: ${formatPrice(context.parsed.y)} ‚ÇΩ`;
                  }
                }
              }
            },
            interaction: { mode: 'nearest', axis: 'x', intersect: false }
          }
        });

        div.querySelector('.buy-btn').onclick = () => window.buy(coinId);
        div.querySelector('.sell-btn').onclick = () => window.sell(coinId);
        div.querySelector('.sell-all-btn').onclick = () => window.sellAll(coinId);
        div.querySelector('.all-btn').onclick = () => window.buyAll(coinId);
      }

      const el = cryptoElements[coinId];
      if (el) {
        el.name.innerHTML = nameHtml;
        el.price.textContent = formatPrice(price) + ' ‚ÇΩ';
        el.change.textContent = changeText;
        el.change.className = `price-change ${changeClass}`;

        el.portAmount.textContent = port.amount.toFixed(4);
        el.portAvg.textContent = formatPrice(port.avgPrice);
        el.portPl.innerHTML = `–ü—Ä–∏–±—ã–ª—å/—É–±—ã—Ç–æ–∫: <span class="${plClass}">${profitLoss >= 0 ? '+' : ''}${plText}‚ÇΩ</span>`;

        el.cooldown.innerHTML = cooldownHtml;
        el.expired.innerHTML = expiredHtml;

        el.buyBtn.disabled = buyDisabled;
        el.buyAllBtn.disabled = buyDisabled;

        const chart = cryptoCharts[coinId];
        if (chart && hist.length > 0) {
          chart.data.labels = hist.map((_, i) => i);
          chart.data.datasets[0].data = hist.slice();
          chart.update('none');
        }
      }
    });
  }

  document.addEventListener('DOMContentLoaded', async () => {
    createParticles();
    await initPrices();
    await catchUpCryptoPrices();
  });
</script>
</body>
</html>
