<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Crismos Shoot - –ö–æ–Ω—Ü–µ–ø—Ç –∏–≥—Ä—ã</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap');
        
        :root {
            --bg-dark: #0f0b15;
            --bg-card: #1a1625;
            --bg-hover: #252033;
            --primary: #8b5cf6;
            --primary-hover: #a78bfa;
            --accent: #f59e0b;
            --christmas-red: #dc2626;
            --christmas-green: #16a34a;
            --snow: #f0f9ff;
            --text-main: #ffffff;
            --text-sec: #94a3b8;
            --border: rgba(139, 92, 246, 0.2);
            --gradient-main: linear-gradient(135deg, #7c3aed, #db2777);
            --gradient-gold: linear-gradient(135deg, #f59e0b, #fbbf24);
            --gradient-christmas: linear-gradient(135deg, #dc2626, #16a34a);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-dark);
            background-image: 
                radial-gradient(circle at 15% 25%, rgba(124, 58, 237, 0.15) 0%, transparent 45%),
                radial-gradient(circle at 85% 75%, rgba(220, 38, 38, 0.1) 0%, transparent 45%);
            color: var(--text-main);
            overflow-x: hidden;
            position: relative;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏–≥—Ä—ã */
        .game-header {
            text-align: center;
            padding: 15px;
            background: var(--gradient-christmas);
            border-radius: 20px;
            margin-bottom: 15px;
            box-shadow: 0 5px 20px rgba(220, 38, 38, 0.3);
            position: relative;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .game-header:hover {
            transform: scale(1.01);
        }
        
        .game-title {
            font-size: 1.8rem;
            font-weight: 900;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 5px;
            color: white;
            text-decoration: none;
        }
        
        .game-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        /* –ù–∞–≤–∏–≥–∞—Ü–∏—è —Å–∫—Ä—ã—Ç–∞ (–∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω–∞ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å) */
        .tabs { display: none; }
        
        /* –°–µ–∫—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ */
        .content-section {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        /* –ò–≥—Ä–æ–≤–∞—è –∞—Ä–µ–Ω–∞ */
        .game-arena {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 20px;
            padding: 10px;
            flex: 1;
            position: relative;
            overflow: hidden;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
        }
        
        .arena-canvas {
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(to bottom, rgba(15, 11, 21, 0.7), rgba(26, 22, 37, 0.9)),
                url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 450"><defs><linearGradient id="sky" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:%231a1f35;stop-opacity:1" /><stop offset="100%" style="stop-color:%230f0b15;stop-opacity:1" /></linearGradient></defs><rect fill="url(%23sky)" width="1200" height="450"/><circle cx="100" cy="80" r="40" fill="%23fbbf24" opacity="0.3"/><polygon points="900,350 920,320 940,350" fill="%2316a34a" opacity="0.4"/><polygon points="950,350 970,310 990,350" fill="%2316a34a" opacity="0.4"/><polygon points="1000,350 1020,330 1040,350" fill="%2316a34a" opacity="0.4"/><rect x="0" y="350" width="1200" height="100" fill="%23e0e7ff" opacity="0.1"/><ellipse cx="200" cy="100" rx="60" ry="20" fill="%23ffffff" opacity="0.1"/><ellipse cx="500" cy="120" rx="80" ry="25" fill="%23ffffff" opacity="0.08"/><ellipse cx="900" cy="90" rx="70" ry="22" fill="%23ffffff" opacity="0.09"/></svg>');
            background-size: cover;
            background-position: center;
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(139, 92, 246, 0.3);
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5);
            touch-action: none;
        }
        
        .arena-canvas.bg-city {
            /* Cyberpunk City - Detailed */
            background: 
                linear-gradient(0deg, rgba(0,0,0,0.9) 0%, transparent 100%),
                repeating-linear-gradient(90deg, 
                    transparent 0, transparent 20px, 
                    rgba(255, 0, 255, 0.1) 20px, rgba(255, 0, 255, 0.1) 22px
                ),
                repeating-linear-gradient(90deg, 
                    transparent 0, transparent 50px, 
                    rgba(0, 255, 255, 0.05) 50px, rgba(0, 255, 255, 0.05) 54px
                ),
                linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
        }
        .arena-canvas.bg-city::before {
            content: '';
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            height: 200px;
            background-image: 
                linear-gradient(transparent 90%, rgba(255,255,0,0.2) 90%),
                linear-gradient(90deg, transparent 90%, rgba(255,255,0,0.2) 90%);
            background-size: 20px 40px;
            opacity: 0.3;
            transform: perspective(500px) rotateX(20deg);
        }
        .arena-canvas.bg-city::after {
            content: 'üåÉ';
            position: absolute;
            font-size: 15rem;
            bottom: 50px;
            right: 20px;
            opacity: 0.15;
            filter: drop-shadow(0 0 20px #d946ef);
            transform: scale(1.5);
        }

        .arena-canvas.bg-snow {
            /* Realistic Winter */
            background: linear-gradient(to bottom, #1e293b 0%, #334155 50%, #e2e8f0 100%);
            overflow: hidden;
        }
        .arena-canvas.bg-snow::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(3px 3px at 100px 50px, #fff, transparent), 
                radial-gradient(4px 4px at 200px 150px, #fff, transparent), 
                radial-gradient(2px 2px at 300px 250px, #fff, transparent), 
                radial-gradient(3px 3px at 400px 350px, #fff, transparent);
            background-size: 400px 400px;
            animation: snow 8s linear infinite;
            opacity: 0.9;
            z-index: 1;
        }
        .arena-canvas.bg-snow::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: 
                radial-gradient(6px 6px at 150px 80px, rgba(255,255,255,0.8), transparent), 
                radial-gradient(5px 5px at 350px 300px, rgba(255,255,255,0.8), transparent);
            background-size: 600px 600px;
            animation: snow 12s linear infinite reverse;
            opacity: 0.6;
            z-index: 2;
        }
        
        .arena-canvas.bg-desert {
            /* Hot Desert */
            background: linear-gradient(to bottom, #7c2d12 0%, #ea580c 50%, #fdba74 100%);
            position: relative;
        }
        .arena-canvas.bg-desert::before {
            content: '‚òÄÔ∏è';
            position: absolute;
            top: 20px;
            right: 40px;
            font-size: 8rem;
            opacity: 0.8;
            filter: blur(4px);
        }
        .arena-canvas.bg-desert::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            background: 
                radial-gradient(circle at 50% 100%, #fbbf24 20%, transparent 21%),
                radial-gradient(circle at 20% 100%, #d97706 20%, transparent 21%),
                radial-gradient(circle at 80% 100%, #b45309 20%, transparent 21%);
            background-size: 300px 150px;
            opacity: 0.4;
        }

        .arena-canvas.bg-forest {
            /* Deep Forest */
            background: linear-gradient(to bottom, #022c22 0%, #064e3b 40%, #065f46 100%);
        }
        .arena-canvas.bg-forest::before {
            content: 'üå≤';
            position: absolute;
            bottom: 20px;
            left: 10%;
            font-size: 8rem;
            opacity: 0.4;
            color: #064e3b;
            text-shadow: 100px 20px 0 #064e3b, 250px -10px 0 #064e3b, 500px 10px 0 #064e3b;
        }
        
        /* –ò–≥—Ä–æ–∫ */
        .player {
            position: absolute;
            left: 10%;
            bottom: 20%;
            width: 80px;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: transform 0.1s;
            z-index: 10;
        }
        
        .player-body {
            width: 80px;
            height: 100px;
            background: transparent;
            position: relative;
            background-image: url('../images/games/bomj.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
            image-rendering: pixelated;
            transform: scaleX(-1);
        }
        
        .weapon {
            width: 70px;
            height: 35px;
            background: transparent;
            background-image: url('../images/games shoot.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            position: absolute;
            right: -35px;
            top: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: left center;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
        }

        .weapon-barrel {
            display: none; /* Hide default barrel if using image */
        }

        .charm {
            position: absolute;
            bottom: -15px;
            right: 10px;
            font-size: 1.4rem;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
            animation: swing 2s ease-in-out infinite;
            transform-origin: top center;
        }

        @keyframes swing {
            0%, 100% { transform: rotate(-10deg); }
            50% { transform: rotate(10deg); }
        }
        
        /* –í—Ä–∞–≥–∏ - –ó–æ–º–±–∏ */
        .enemy {
            position: absolute;
            right: -100px;
            bottom: 20%;
            width: 80px;
            height: 100px;
            transition: left 0.1s linear;
        }
        
        .enemy.boss {
            width: 140px;
            height: 160px;
        }
        
        .grinch-body {
            width: 100%;
            height: 100%;
            background: transparent;
            background-image: url('../images/games/zombie.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center bottom;
        }

        /* Health Bars */
        .health-bar-mini {
            position: absolute;
            top: -15px;
            left: 0;
            width: 100%;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .health-bar-mini .fill {
            height: 100%;
            background: #dc2626;
            width: 100%;
            transition: width 0.2s;
        }

        .player .health-bar-mini .fill {
            background: #16a34a;
        }
        
        /* –ü—É–ª–∏ */
        .bullet {
            position: absolute;
            width: 12px;
            height: 6px;
            background: #fbbf24;
            border-radius: 4px;
            box-shadow: 0 0 10px #f59e0b;
        }
        
        /* UI –∏–≥—Ä—ã */
        .game-ui {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            gap: 10px;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        
        .ui-panel {
            background: rgba(26, 22, 37, 0.9);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 15px;
            flex: 1;
            min-width: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .ui-label {
            font-size: 0.75rem;
            color: var(--text-sec);
            margin-bottom: 4px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .ui-value {
            font-size: 1.2rem;
            font-weight: 800;
            color: var(--text-main);
            white-space: nowrap;
        }
        
        .health-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        
        .health-fill {
            height: 100%;
            background: var(--christmas-red);
            transition: width 0.3s;
        }

        .ammo-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }

        .ammo-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.2s;
        }
        
        /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            padding-bottom: 20px;
        }

        .action-row {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            padding: 16px;
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 14px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            touch-action: manipulation;
            flex: 1;
        }
        
        .control-btn:active {
            transform: scale(0.96);
        }

        .btn-shoot {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: none;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.4);
            font-size: 1.2rem;
        }

        .btn-reload {
            background: var(--bg-hover);
            border-color: var(--text-sec);
        }

        .btn-upgrade {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        .btn-heal {
            background: linear-gradient(135deg, #ec4899, #be185d);
            border: none;
            box-shadow: 0 4px 15px rgba(236, 72, 153, 0.4);
        }

        .btn-claim {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border: none;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
        }

        .control-btn:disabled {
            opacity: 0.5;
            filter: grayscale(1);
            cursor: not-allowed;
        }
        
        /* Betting Overlay */
        .bet-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 11, 21, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
        }

        .bet-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: var(--gradient-christmas);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
        }

        .bet-input-container {
            margin-bottom: 20px;
            width: 100%;
            max-width: 300px;
        }

        .bet-input {
            width: 100%;
            background: rgba(255,255,255,0.1);
            border: 2px solid var(--border);
            padding: 15px;
            border-radius: 12px;
            color: white;
            font-size: 1.5rem;
            text-align: center;
            font-weight: bold;
            outline: none;
        }

        .bet-input:focus {
            border-color: var(--primary);
        }
        
        /* Skins Overlay */
        .skins-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 11, 21, 0.95);
            z-index: 200;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        
        .skins-overlay.hidden {
            display: none;
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
            overflow-y: auto;
            max-height: 70vh;
        }

        .skin-card {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .skin-card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
        }

        .skin-card.selected {
            border-color: var(--accent);
            background: rgba(245, 158, 11, 0.1);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.2);
        }

        .skin-card.locked {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .skin-image {
            width: 80px;
            height: 100px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin-bottom: 10px;
        }

        .skin-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .skin-bonus {
            font-size: 0.8rem;
            color: #4ade80;
        }
        
        /* –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å */
        @media (min-width: 768px) {
            .controls {
                grid-template-columns: repeat(4, 1fr);
            }
            .action-row {
                grid-column: auto;
            }
        }
        
        .damage-text {
            position: absolute;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
            animation: floatUp 0.8s forwards;
        }

        @keyframes floatUp {
            to { transform: translateY(-50px); opacity: 0; }
        }

        .reload-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: bold;
            display: none;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- –ó–∞–≥–æ–ª–æ–≤–æ–∫ -->
        <div class="game-header" onclick="window.location.href='../index.html'">
            <h1 class="game-title">üéÑ Crismos Shoot üéÅ</h1>
            <p class="game-subtitle">–í—ã–∂–∏–≤–∞–π, —É–ª—É—á—à–∞–π –æ—Ä—É–∂–∏–µ, –∑–∞–±–∏—Ä–∞–π –∫—É—à!</p>
        </div>
        
        <!-- –ì–µ–π–º–ø–ª–µ–π -->
        <div class="content-section" id="gameplay">
            <!-- Skins Overlay -->
            <div id="skinsOverlay" class="skins-overlay hidden">
                <h2 style="font-size: 2rem; margin-bottom: 20px;">–ì–∞—Ä–¥–µ—Ä–æ–±</h2>
                
                <div class="skin-tabs" style="display: flex; gap: 10px; margin-bottom: 20px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 12px;">
                    <button class="control-btn" id="tabAgents" style="padding: 10px 20px; min-width: 120px; background: var(--primary);">–°–∫–∏–Ω—ã</button>
                    <button class="control-btn" id="tabBackgrounds" style="padding: 10px 20px; min-width: 120px; background: transparent; border-color: transparent;">–§–æ–Ω—ã</button>
                </div>

                <div class="skins-grid" id="skinsGrid">
                    <!-- Skins injected by JS -->
                </div>
                <button class="control-btn" id="closeSkinsBtn" style="max-width: 200px; margin-top: 10px;">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>

            <div class="game-arena">
                <!-- –û–≤–µ—Ä–ª–µ–π —Å—Ç–∞–≤–æ–∫/—Å—Ç–∞—Ä—Ç–∞ -->
                <div class="bet-overlay" id="betOverlay">
                    <h2 class="bet-title">–í–•–û–î –í –ò–ì–†–£</h2>
                    
                    <div class="bet-input-container">
                        <label style="color: #94a3b8; display: block; margin-bottom: 8px;">–í–∞—à–∞ —Å—Ç–∞–≤–∫–∞:</label>
                        <input type="number" id="betInput" class="bet-input" value="100" min="10" step="10">
                    </div>

                    <p style="color: #94a3b8; margin-bottom: 20px; font-size: 0.9rem;">–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞: 10 –º–æ–Ω–µ—Ç</p>
                    
                    <div style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; margin-bottom: 30px; max-width: 400px; text-align: left;">
                        <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">üíÄ</span>
                            <div>
                                <div style="color: white; font-weight: bold;">–£–±–∏–≤–∞–π –∑–æ–º–±–∏</div>
                                <div style="color: #94a3b8; font-size: 0.85rem;">–ù–∞–≥—Ä–∞–¥–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å—Ç–∞–≤–∫–∏!</div>
                            </div>
                        </div>
                        <div style="margin-bottom: 12px; display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">‚ö°</span>
                            <div>
                                <div style="color: white; font-weight: bold;">–î–∏–Ω–∞–º–∏–∫–∞</div>
                                <div style="color: #94a3b8; font-size: 0.85rem;">–ó–æ–º–±–∏ –∏–¥—É—Ç –∫ —Ç–µ–±–µ! –ù–µ –¥–∞–π –∏–º –¥–æ–π—Ç–∏!</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;">üëï</span>
                            <div>
                                <div style="color: white; font-weight: bold;">–°–∫–∏–Ω—ã</div>
                                <div style="color: #94a3b8; font-size: 0.85rem;">–ò—Å–ø–æ–ª—å–∑—É–π —Å–∫–∏–Ω—ã –¥–ª—è –±–æ–Ω—É—Å–æ–≤!</div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; width: 100%; max-width: 400px;">
                        <button class="control-btn" id="openSkinsBtn" style="flex: 1; background: linear-gradient(135deg, #6366f1, #4f46e5);">üëï –°–ö–ò–ù–´</button>
                        <button class="control-btn btn-claim" id="startGameBtn" style="flex: 2; font-size: 1.3rem;">
                            –ò–ì–†–ê–¢–¨
                        </button>
                    </div>
                    
                    <p id="betError" style="color: #ef4444; margin-top: 15px; display: none;">–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!</p>
                    <button class="control-btn" onclick="location.href='../index.html'" style="margin-top: 20px; background: transparent; border: none; color: #6b7280;">‚Üê –ù–∞ –≥–ª–∞–≤–Ω—É—é</button>
                </div>

                <!-- –ö–∞–Ω–≤–∞—Å –∏–≥—Ä—ã -->
                <div class="arena-canvas" id="gameCanvas">
                    <div class="player" id="player">
                        <div class="health-bar-mini"><div class="fill" id="playerMiniHp"></div></div>
                        <div class="player-body">
                            <div class="weapon">
                                <div class="weapon-barrel"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏ -->
                    <div class="reload-indicator" id="reloadIndicator">–ü–ï–†–ï–ó–ê–†–Ø–î–ö–ê...</div>
                </div>
                
                <!-- UI –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
                <div class="game-ui">
                    <div class="ui-panel">
                        <div class="ui-label">–í—ã–∏–≥—Ä—ã—à</div>
                        <div class="ui-value" style="color: #fbbf24;" id="sessionCoinsDisplay">+0</div>
                    </div>
                    <div class="ui-panel">
                        <div class="ui-label">–ü–∞—Ç—Ä–æ–Ω—ã</div>
                        <div class="ui-value" id="ammoText">12/12</div>
                        <div class="ammo-bar-container">
                            <div class="ammo-fill" id="ammoBar" style="width: 100%;"></div>
                        </div>
                    </div>
                    <div class="ui-panel">
                        <div class="ui-label">–ó–¥–æ—Ä–æ–≤—å–µ</div>
                        <div class="ui-value" id="hpText">100</div>
                        <div class="health-bar-container">
                            <div class="health-fill" id="healthBar" style="width: 100%;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
            <div class="controls">
                <button class="control-btn btn-shoot" id="shootBtn">
                    <span>üî• –û–ì–û–ù–¨</span>
                </button>
                
                <button class="control-btn btn-reload" id="reloadBtn">
                    <span>üîÑ</span>
                    <span style="font-size: 0.8rem;">–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞</span>
                </button>

                <div class="action-row" style="grid-column: span 2; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button class="control-btn btn-upgrade" id="upgradeBtn">
                        <span>‚ö° –£–õ–£–ß–®–ò–¢–¨</span>
                        <span style="font-size: 0.8rem; opacity: 0.9;" id="upgradeCostText">50 üí∞</span>
                    </button>

                    <button class="control-btn btn-grenade" id="grenadeBtn">
                        <span>üí£ –ì–†–ê–ù–ê–¢–ê</span>
                        <span style="font-size: 0.8rem; opacity: 0.9;" id="grenadeCostText">50 üí∞</span>
                    </button>
                    
                    <button class="control-btn btn-claim" id="claimBtn" style="grid-column: span 2;">
                        <span>üèÜ –ó–ê–ë–†–ê–¢–¨</span>
                        <span style="font-size: 0.8rem; opacity: 0.9;" id="claimText"></span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, updateDoc, runTransaction } from "https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js";

        // --- Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyBVra2JN-C7-1b_Qa4cU8--XvJ83lymiM8",
            authDomain: "dropwin-8d94b.firebaseapp.com",
            projectId: "dropwin-8d94b",
            storageBucket: "dropwin-8d94b.firebasestorage.app",
            messagingSenderId: "988974289403",
            appId: "1:988974289403:web:886d34e6f65920a105fb5e",
            measurementId: "G-BK010MHN8N"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Game State ---
        let gameState = {
            isPlaying: false,
            health: 100,
            maxHealth: 100,
            sessionCoins: 0, 
            weaponLevel: 1,
            damage: 25,
            currentAmmo: 12,
            maxAmmo: 12,
            isReloading: false,
            lastShotTime: 0, // Fire rate limit
            fireRate: 150, // ms
            wave: 1,
            enemiesKilled: 0,
            globalBalance: 0, 
            bet: 100,
            volatility: 0.5, // 0-1: Risk factor (Casino Logic)
            equipped: {
                agent: 'bomj', 
                weapon: 'default',
                bg: 'default',
                charm: null,
                charmEmoji: null
            },
            bonuses: {
                hp: 0,
                damage: 0,
                speed: 1
            }
        };

        let currentUser = null;
        let enemies = [];
        let bullets = [];
        let gameLoopId;
        let enemySpawnTimeout;
        let currentSkinTab = 'agent'; // 'agent' or 'bg'
        
        const SKINS_CONFIG = {
            // Agents
            'bomj': { name: '–ë–æ–º–∂', bonus: '–ù–µ—Ç –±–æ–Ω—É—Å–∞', img: '../images/games/bomj.png', type: 'agent' },
            'boy': { name: '–ü–∞—Ü–∞–Ω', bonus: 'HP +20', img: '../images/games/boy.png', type: 'agent' },
            'people': { name: '–ß–µ–ª–æ–≤–µ–∫', bonus: '–£—Ä–æ–Ω +5', img: '../images/games/people.png', type: 'agent' },
            'gnom': { name: '–ì–Ω–æ–º', bonus: '–°–∫–æ—Ä–æ—Å—Ç—å +10%', img: '../images/games/gnom.png', type: 'agent' },
            
            // Backgrounds
            'bg-city': { name: '–ì–æ—Ä–æ–¥', bonus: '–£–¥–∞—á–∞ +5%', img: '', type: 'bg', cssClass: 'bg-city' },
            'bg-snow': { name: '–°–Ω–µ–≥', bonus: '–ó–∞–º–µ–¥–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤', img: '', type: 'bg', cssClass: 'bg-snow' },
            'bg-desert': { name: '–ü—É—Å—Ç—ã–Ω—è', bonus: '–ó–æ–ª–æ—Ç–æ +5%', img: '', type: 'bg', cssClass: 'bg-desert' },
            'bg-forest': { name: '–õ–µ—Å', bonus: 'HP +10', img: '', type: 'bg', cssClass: 'bg-forest' }
        };

        // --- DOM Elements ---
        const ui = {
            gameCanvas: document.getElementById('gameCanvas'),
            player: document.getElementById('player'),
            playerBody: document.querySelector('.player-body'),
            playerMiniHp: document.getElementById('playerMiniHp'),
            weapon: document.querySelector('.weapon'),
            betOverlay: document.getElementById('betOverlay'),
            startGameBtn: document.getElementById('startGameBtn'),
            betInput: document.getElementById('betInput'),
            betError: document.getElementById('betError'),
            sessionCoins: document.getElementById('sessionCoinsDisplay'),
            ammoText: document.getElementById('ammoText'),
            ammoBar: document.getElementById('ammoBar'),
            hpText: document.getElementById('hpText'),
            healthBar: document.getElementById('healthBar'),
            reloadIndicator: document.getElementById('reloadIndicator'),
            upgradeBtn: document.getElementById('upgradeBtn'),
            upgradeCostText: document.getElementById('upgradeCostText'),
            grenadeBtn: document.getElementById('grenadeBtn'),
            grenadeCostText: document.getElementById('grenadeCostText'),
            claimBtn: document.getElementById('claimBtn'),
            claimText: document.getElementById('claimText'),
            shootBtn: document.getElementById('shootBtn'),
            reloadBtn: document.getElementById('reloadBtn'),
            skinsOverlay: document.getElementById('skinsOverlay'),
            skinsGrid: document.getElementById('skinsGrid'),
            openSkinsBtn: document.getElementById('openSkinsBtn'),
            closeSkinsBtn: document.getElementById('closeSkinsBtn')
        };

        // --- Sound Manager ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'shoot') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400 - (gameState.weaponLevel * 20), now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'reload') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'upgrade') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'explosion') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.5);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // --- Auth & Init ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                await loadUserData();
            } else {
                // Guest or redirect
                // For demo, assume guest
                gameState.globalBalance = 1000;
                applyEquippedItems();
            }
        });

        async function loadUserData() {
            if (!currentUser) return;
            const docSnap = await getDoc(doc(db, 'users', currentUser.uid));
            if (docSnap.exists()) {
                const data = docSnap.data();
                gameState.globalBalance = data.balance || 0;
                currentUser.inventory = data.inventory || []; // Store inventory for skins check
                if (data.gameSettings && data.gameSettings.crismos) {
                    gameState.equipped = { ...gameState.equipped, ...data.gameSettings.crismos };
                }
            }
            applyEquippedItems();
        }

        function applyEquippedItems() {
            // Calculate Bonuses
            gameState.bonuses = { hp: 0, damage: 0, speed: 1, goldMult: 1, luck: 0, enemySpeedMult: 1 };
            
            // --- AGENT BONUSES ---
            const skinName = gameState.equipped.agent || 'bomj';
            const skinConfig = SKINS_CONFIG[skinName] || SKINS_CONFIG['bomj'];
            
            // Set Image
            ui.playerBody.style.backgroundImage = `url('${skinConfig.img}')`;
            ui.playerBody.style.backgroundPosition = 'center bottom';
            ui.playerBody.style.backgroundSize = 'contain';

            // Apply specific agent bonuses
            if (skinName === 'boy') gameState.bonuses.hp += 20;
            if (skinName === 'people') gameState.bonuses.damage += 5;
            if (skinName === 'gnom') gameState.bonuses.speed += 0.1; // +10% reload speed

            // --- BACKGROUND BONUSES ---
            const bgName = gameState.equipped.bg || 'default';
            const bgConfig = SKINS_CONFIG[bgName];
            
            ui.gameCanvas.className = 'arena-canvas'; // Reset
            
            if (bgConfig) {
                if (bgConfig.cssClass) ui.gameCanvas.classList.add(bgConfig.cssClass);
                
                if (bgName === 'bg-city') gameState.bonuses.luck += 0.05; // 5% crit chance?
                if (bgName === 'bg-desert') gameState.bonuses.goldMult += 0.05; // +5% gold
                if (bgName === 'bg-snow') gameState.bonuses.enemySpeedMult -= 0.1; // 10% slower enemies
                if (bgName === 'bg-forest') gameState.bonuses.hp += 10;
            } else {
                 // Fallback legacy logic
                 if (bgName === 'snow') ui.gameCanvas.classList.add('bg-snow');
                 else ui.gameCanvas.classList.add('bg-default');
            }

            // Weapon Skin
            const weaponName = gameState.equipped.weapon || 'default';
            if (weaponName === '–ó–æ–ª–æ—Ç–æ–π') ui.weapon.style.background = 'linear-gradient(90deg, #fbbf24, #d97706)';
            else if (weaponName === '–°–Ω–µ–∂–Ω—ã–π') ui.weapon.style.background = 'linear-gradient(90deg, #e0f2fe, #bae6fd)';
            else if (weaponName === '–ì—Ä–∞—Ñ—Ñ–∏—Ç–∏') ui.weapon.style.background = 'linear-gradient(90deg, #ec4899, #8b5cf6)';
            
            // Charm
            const oldCharm = ui.weapon.querySelector('.charm');
            if (oldCharm) oldCharm.remove();
            if (gameState.equipped.charmEmoji) {
                const charm = document.createElement('div');
                charm.className = 'charm';
                charm.textContent = gameState.equipped.charmEmoji;
                ui.weapon.appendChild(charm);
            }
        }

        // --- Skins Logic ---
        ui.openSkinsBtn.addEventListener('click', () => {
            renderSkins();
            ui.skinsOverlay.classList.remove('hidden');
        });

        ui.closeSkinsBtn.addEventListener('click', () => {
            ui.skinsOverlay.classList.add('hidden');
        });
        
        // Tab Listeners
        document.getElementById('tabAgents').addEventListener('click', () => {
            currentSkinTab = 'agent';
            updateTabs();
            renderSkins();
        });
        document.getElementById('tabBackgrounds').addEventListener('click', () => {
            currentSkinTab = 'bg';
            updateTabs();
            renderSkins();
        });
        
        function updateTabs() {
            const btnAgent = document.getElementById('tabAgents');
            const btnBg = document.getElementById('tabBackgrounds');
            
            if (currentSkinTab === 'agent') {
                btnAgent.style.background = 'var(--primary)';
                btnAgent.style.borderColor = 'var(--border)';
                btnBg.style.background = 'transparent';
                btnBg.style.borderColor = 'transparent';
            } else {
                btnBg.style.background = 'var(--primary)';
                btnBg.style.borderColor = 'var(--border)';
                btnAgent.style.background = 'transparent';
                btnAgent.style.borderColor = 'transparent';
            }
        }

        function renderSkins() {
            ui.skinsGrid.innerHTML = '';
            
            Object.keys(SKINS_CONFIG).forEach(key => {
                const skin = SKINS_CONFIG[key];
                if (skin.type !== currentSkinTab) return; // Filter by tab
                
                const card = document.createElement('div');
                
                // Check ownership
                let owned = false;
                
                // Defaults
                if (key === 'bomj' || key === 'bg-city') owned = true; 
                
                if (currentUser && currentUser.inventory) {
                    // Check if inventory has item with matching name (looser check to fix issues)
                    if (currentUser.inventory.some(i => i.name === skin.name)) {
                        owned = true;
                    }
                }

                const isEquipped = (skin.type === 'agent' && gameState.equipped.agent === key) || 
                                   (skin.type === 'bg' && gameState.equipped.bg === key);

                card.className = `skin-card ${owned ? '' : 'locked'} ${isEquipped ? 'selected' : ''}`;
                
                // Visual for card
                let visual = '';
                if (skin.type === 'bg') {
                    // Show small preview of CSS class
                    visual = `<div class="skin-image ${skin.cssClass}" style="width: 100%; height: 80px; border-radius: 8px; margin-bottom: 10px;"></div>`;
                } else {
                    visual = `<div class="skin-image" style="background-image: url('${skin.img}')"></div>`;
                }

                card.innerHTML = `
                    ${visual}
                    <div class="skin-name">${skin.name}</div>
                    <div class="skin-bonus">${skin.bonus}</div>
                    ${!owned ? '<div style="margin-top:5px; font-size:0.8rem;">üîí –ó–∞–∫—Ä—ã—Ç–æ</div>' : ''}
                `;
                
                if (owned) {
                    card.addEventListener('click', async () => {
                        if (skin.type === 'agent') gameState.equipped.agent = key;
                        if (skin.type === 'bg') gameState.equipped.bg = key;
                        
                        applyEquippedItems();
                        renderSkins(); // Re-render to update selection
                        
                        // Save preference
                        if (currentUser) {
                             if (!currentUser.gameSettings) currentUser.gameSettings = {};
                             if (!currentUser.gameSettings.crismos) currentUser.gameSettings.crismos = {};
                             
                             if (skin.type === 'agent') currentUser.gameSettings.crismos.agent = key;
                             if (skin.type === 'bg') currentUser.gameSettings.crismos.bg = key;
                             
                             await updateDoc(doc(db, 'users', currentUser.uid), {
                                 gameSettings: currentUser.gameSettings
                             });
                        }
                    });
                }
                
                ui.skinsGrid.appendChild(card);
            });
        }

        // --- Core Game Logic ---
        
        ui.startGameBtn.addEventListener('click', async () => {
            if (!currentUser) { alert("–í–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç!"); return; }
            
            const bet = parseInt(ui.betInput.value);
            if (isNaN(bet) || bet < 10) {
                ui.betError.textContent = "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç–∞–≤–∫–∞ 10!";
                ui.betError.style.display = 'block';
                return;
            }

            if (gameState.globalBalance < bet) {
                ui.betError.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!";
                ui.betError.style.display = 'block';
                return;
            }

            ui.startGameBtn.disabled = true;
            ui.startGameBtn.textContent = "–ó–∞–ø—É—Å–∫...";
            
            try {
                // Transaction: Deduct bet coins
                await runTransaction(db, async (t) => {
                    const ref = doc(db, 'users', currentUser.uid);
                    const snap = await t.get(ref);
                    const bal = snap.data().balance || 0;
                    if (bal < bet) throw "No money";
                    t.update(ref, { balance: bal - bet });
                });
                
                gameState.globalBalance -= bet;
                gameState.bet = bet;
                startGame();
            } catch (e) {
                ui.betError.textContent = "–û—à–∏–±–∫–∞: " + e;
                ui.betError.style.display = 'block';
                ui.startGameBtn.disabled = false;
                ui.startGameBtn.textContent = "–ò–ì–†–ê–¢–¨";
            }
        });

        function startGame() {
            ui.betOverlay.style.display = 'none';
            gameState.isPlaying = true;
            gameState.maxHealth = 100 + gameState.bonuses.hp;
            gameState.health = gameState.maxHealth;
            gameState.sessionCoins = 0;
            gameState.weaponLevel = 1;
            gameState.damage = 25 + gameState.bonuses.damage;
            gameState.currentAmmo = 12;
            gameState.maxAmmo = 12;
            gameState.wave = 1;
            gameState.enemiesKilled = 0;
            
            // Casino Volatility Logic
            gameState.volatility = Math.random(); 
            // < 0.3: Low Risk (Slow zombies, Normal pay)
            // 0.3 - 0.7: Normal
            // > 0.7: High Risk (Fast zombies, High pay)
            
            let vibeMsg = "–£–¥–∞—á–∏!";
            if (gameState.volatility > 0.8) vibeMsg = "üî• –•–ê–†–î–ö–û–†: –ó–æ–º–±–∏ –±—ã—Å—Ç—Ä—ã–µ, –Ω–∞–≥—Ä–∞–¥–∞ x1.5!";
            else if (gameState.volatility < 0.2) vibeMsg = "‚òòÔ∏è –õ–ê–ô–¢: –ó–æ–º–±–∏ –º–µ–¥–ª–µ–Ω–Ω—ã–µ";
            
            showFloatingText(vibeMsg, ui.gameCanvas.offsetWidth/2, ui.gameCanvas.offsetHeight/2);
            
            bullets.forEach(b => b.remove());
            bullets = [];
            enemies.forEach(e => e.element.remove());
            enemies = [];
            
            updateUI();
            
            gameLoopId = requestAnimationFrame(gameLoop);
            scheduleNextEnemy();
        }

        function scheduleNextEnemy() {
            if (!gameState.isPlaying) return;

            spawnEnemy();

            // Calculate delay based on kills/wave
            // Start at 2000ms, decrease by 50ms per kill, min 600ms
            let delay = Math.max(600, 2000 - (gameState.enemiesKilled * 50));
            
            // Also scale with wave to make it harder steps
            delay = delay / (1 + (gameState.wave * 0.1));

            enemySpawnTimeout = setTimeout(scheduleNextEnemy, delay);
        }

        function spawnEnemy() {
            if (!gameState.isPlaying) return;
            
            const el = document.createElement('div');
            el.className = 'enemy';
            el.innerHTML = `
                <div class="health-bar-mini"><div class="fill" style="width: 100%"></div></div>
                <div class="grinch-body"></div>
            `;
            ui.gameCanvas.appendChild(el);
            
            // Stronger enemies over time
            const hp = 30 + (gameState.wave * 15) + (gameState.enemiesKilled * 2);
            
            // Speed Calculation with Volatility
            let speed = (1.5 + (gameState.wave * 0.4) + (gameState.enemiesKilled * 0.05));
            
            // Volatility impact (Casino Logic: High Risk = FAST Death possible)
            if (gameState.volatility > 0.9) {
                speed *= 2.5; // Extreme speed, likely death
            } else if (gameState.volatility > 0.7) {
                speed *= 1.6;
            } else if (gameState.volatility < 0.2) {
                speed *= 0.8;
            }
            
            // Random flux
            speed += (Math.random() - 0.5); 

            // Spawn Distance (Chance to spawn closer if unlucky)
            let spawnX = ui.gameCanvas.offsetWidth + 50;
            if (gameState.volatility > 0.8 && Math.random() > 0.7) {
                 spawnX = ui.gameCanvas.offsetWidth * 0.6; // Spawn much closer!
            }

            const enemy = {
                element: el,
                hpBar: el.querySelector('.fill'),
                x: spawnX,
                hp: hp,
                maxHp: hp,
                speed: Math.max(0.5, speed)
            };
            enemies.push(enemy);
        }

        function gameLoop() {
            if (!gameState.isPlaying) return;

            // Move bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += 10;
                b.element.style.left = b.x + 'px';
                
                if (b.x > ui.gameCanvas.offsetWidth) {
                    b.element.remove();
                    bullets.splice(i, 1);
                    continue;
                }

                // Collision
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const eRect = e.element.getBoundingClientRect();
                    const bRect = b.element.getBoundingClientRect();

                    if (
                        bRect.right > eRect.left &&
                        bRect.left < eRect.right &&
                        bRect.bottom > eRect.top &&
                        bRect.top < eRect.bottom
                    ) {
                        // Hit
                        createHitEffect(e.x, 250); // Approximate Y
                        e.hp -= gameState.damage;
                        // Update enemy mini HP
                        e.hpBar.style.width = Math.max(0, (e.hp / e.maxHp) * 100) + '%';
                        
                        playSound('hit');
                        
                        b.element.remove();
                        bullets.splice(i, 1);
                        
                        if (e.hp <= 0) {
                            handleEnemyDeath(e);
                            enemies.splice(j, 1);
                        }
                        break; 
                    }
                }
            }

            // Move enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.x -= e.speed;
                e.element.style.left = e.x + 'px';
                
                // Player Collision logic
                // Player is at left: 10% (approx 100px)
                const playerX = ui.player.offsetLeft + 60; // Body width approx
                
                if (e.x < playerX) { 
                    // Hit Player
                    const now = Date.now();
                    // Hit every 1 second
                    if (!e.lastHit || now - e.lastHit > 1000) {
                         e.lastHit = now;
                         gameState.health = Math.max(0, gameState.health - 20); // Deal 20 damage
                         playSound('hit');
                         
                         // Visual feedback on player
                         ui.player.style.filter = 'brightness(0.5) sepia(1) hue-rotate(-50deg) saturate(5)';
                         setTimeout(() => ui.player.style.filter = 'none', 200);
                         
                         updateUI();

                         if (gameState.health <= 0) {
                             gameOver();
                             return;
                         }
                    }
                    
                    // Stop enemy from passing through? Or let them walk through?
                    // Let's push them back slightly to simulate "blocking" or just keep them there
                    e.x = playerX; 
                    e.element.style.left = e.x + 'px';
                }
            }

            updateUI();
            requestAnimationFrame(gameLoop);
        }

        function shoot() {
            if (!gameState.isPlaying || gameState.isReloading) return;
            
            const now = Date.now();
            if (now - gameState.lastShotTime < gameState.fireRate) return;
            gameState.lastShotTime = now;

            if (gameState.currentAmmo <= 0) {
                reload();
                return;
            }

            gameState.currentAmmo--;
            playSound('shoot');
            
            // Recoil animation
            ui.player.style.transform = 'translateX(-10px)';
            setTimeout(() => ui.player.style.transform = 'none', 50);

            const b = document.createElement('div');
            b.className = 'bullet';
            b.style.top = (ui.player.offsetTop + 45) + 'px'; // Adjust for weapon pos
            b.style.left = (ui.player.offsetLeft + 60) + 'px';
            ui.gameCanvas.appendChild(b);
            
            bullets.push({
                element: b,
                x: ui.player.offsetLeft + 60
            });
            
            updateUI();
        }

        function reload() {
            if (gameState.isReloading || gameState.currentAmmo === gameState.maxAmmo) return;
            
            gameState.isReloading = true;
            ui.reloadIndicator.style.display = 'block';
            playSound('reload');
            updateUI();
            
            // Reload speed bonus
            const reloadTime = 1500 / (gameState.bonuses.speed || 1);

            setTimeout(() => {
                gameState.currentAmmo = gameState.maxAmmo;
                gameState.isReloading = false;
                ui.reloadIndicator.style.display = 'none';
                updateUI();
            }, reloadTime);
        }

        function upgradeWeapon() {
            // Upgrade cost scales with Bet too? Maybe.
            // Let's keep it fixed relative to earnings.
            // Or maybe cost = 50% of Bet.
            const cost = Math.ceil(gameState.bet * 0.5) * gameState.weaponLevel;
            
            if (gameState.sessionCoins >= cost) {
                gameState.sessionCoins -= cost;
                gameState.weaponLevel++;
                gameState.damage += Math.ceil(gameState.bet * 0.1); // Damage scales with bet
                gameState.maxAmmo += 2;
                gameState.currentAmmo = gameState.maxAmmo; // Free refill
                playSound('upgrade');
                showFloatingText('UPGRADED!', ui.player.offsetLeft, ui.player.offsetTop);
                updateUI();
            } else {
                ui.upgradeBtn.classList.add('shake');
                setTimeout(() => ui.upgradeBtn.classList.remove('shake'), 500);
            }
        }

        function healPlayer() {
            // Heal cost = 30% of Bet * Level?
            // Let's say cost = 40% of Bet.
            const cost = Math.ceil(gameState.bet * 0.4);
            
            if (gameState.health >= gameState.maxHealth) return;

            if (gameState.sessionCoins >= cost) {
                gameState.sessionCoins -= cost;
                gameState.health = Math.min(gameState.health + 25, gameState.maxHealth);
                playSound('heal');
                showFloatingText('+25 HP', ui.player.offsetLeft, ui.player.offsetTop - 50);
                updateUI();
            } else {
                ui.healBtn.classList.add('shake');
                setTimeout(() => ui.healBtn.classList.remove('shake'), 500);
            }
        }

        async function claim() {
            if (!gameState.isPlaying) return;
            
            gameState.isPlaying = false;
            cancelAnimationFrame(gameLoopId);
            clearTimeout(enemySpawnTimeout);
            
            ui.startGameBtn.textContent = "–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...";
            
            try {
                if (currentUser) {
                    await updateDoc(doc(db, 'users', currentUser.uid), {
                        balance: (gameState.globalBalance || 0) + gameState.sessionCoins + gameState.bet // Return bet + earnings? 
                        // Usually betting games: You bet 100. If you lose, you lose 100.
                        // If you claim, you get what you earned.
                        // Does "sessionCoins" include the bet? 
                        // In my logic: sessionCoins starts at 0. Kills add coins.
                        // So if I bet 100, kill 1 enemy (+5), and claim... I get 5. Net -95.
                        // That's bad.
                        // Usually you keep the bet if you survive? Or the bet is sunk cost?
                        // "Entry fee" implies sunk cost.
                        // "Bet" implies you get it back + profit.
                        // Let's assume Bet is returned on Claim.
                    });
                }
                const total = gameState.bet + gameState.sessionCoins;
                alert(`–í—ã –∑–∞–±—Ä–∞–ª–∏ ${total} –º–æ–Ω–µ—Ç! (–°—Ç–∞–≤–∫–∞ ${gameState.bet} + –í—ã–∏–≥—Ä—ã—à ${gameState.sessionCoins})`);
                resetGame();
            } catch (e) {
                alert("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: " + e);
                resetGame();
            }
        }

        function gameOver() {
            gameState.isPlaying = false;
            cancelAnimationFrame(gameLoopId);
            clearTimeout(enemySpawnTimeout);
            
            alert("–í–´ –ü–†–û–ò–ì–†–ê–õ–ò! –ó–æ–º–±–∏ –¥–æ–±—Ä–∞–ª–∏—Å—å –¥–æ –≤–∞—Å. –°—Ç–∞–≤–∫–∞ –ø–æ—Ç–µ—Ä—è–Ω–∞.");
            resetGame();
        }

        function resetGame() {
            ui.betOverlay.style.display = 'flex';
            ui.startGameBtn.disabled = false;
            ui.startGameBtn.textContent = "–ò–ì–†–ê–¢–¨";
            gameState.sessionCoins = 0;
            gameState.weaponLevel = 1;
            updateUI();
        }

        // --- Helpers ---
        function updateUI() {
            // Show Bet Recovery Progress
            ui.sessionCoins.textContent = `${gameState.sessionCoins} / ${gameState.bet}`;
            if (gameState.sessionCoins >= gameState.bet) {
                ui.sessionCoins.style.color = '#4ade80'; // Green (Profit)
                ui.claimText.textContent = `(+${gameState.sessionCoins - gameState.bet})`;
            } else {
                ui.sessionCoins.style.color = '#fbbf24'; // Yellow
                ui.claimText.textContent = `(-${gameState.bet - gameState.sessionCoins})`;
            }

            ui.ammoText.textContent = `${gameState.currentAmmo}/${gameState.maxAmmo}`;
            ui.ammoBar.style.width = (gameState.currentAmmo / gameState.maxAmmo * 100) + '%';
            
            ui.hpText.textContent = gameState.health;
            ui.healthBar.style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            ui.playerMiniHp.style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            
            // Update Costs
            const upgradeCost = Math.ceil(gameState.bet * 0.3) * gameState.weaponLevel;
            ui.upgradeCostText.textContent = `${upgradeCost} üí∞`;
            
            const grenadeCost = Math.ceil(gameState.bet * 0.3);
            ui.grenadeCostText.textContent = `${grenadeCost} üí∞`;
            
            // Disable buttons if no money
            ui.upgradeBtn.style.opacity = gameState.sessionCoins < upgradeCost ? '0.5' : '1';
            ui.grenadeBtn.style.opacity = gameState.sessionCoins < grenadeCost ? '0.5' : '1';
            
            if (gameState.isReloading) {
                ui.shootBtn.disabled = true;
                ui.reloadBtn.disabled = true;
                ui.shootBtn.textContent = '‚è≥';
            } else {
                ui.shootBtn.disabled = false;
                ui.reloadBtn.disabled = false;
                ui.shootBtn.textContent = 'üî• –û–ì–û–ù–¨';
            }
        }

        function showFloatingText(text, x, y) {
            const el = document.createElement('div');
            el.className = 'damage-text';
            el.textContent = text;
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            ui.gameCanvas.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function createHitEffect(x, y) {
            const el = document.createElement('div');
            el.textContent = 'üí•';
            el.style.position = 'absolute';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            el.style.fontSize = '2rem';
            el.style.pointerEvents = 'none';
            ui.gameCanvas.appendChild(el);
            setTimeout(() => el.remove(), 200);
        }

        // --- Inputs ---
        ui.shootBtn.addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });
        ui.shootBtn.addEventListener('click', shoot);
        
        // Mobile: Tap on canvas to shoot
        ui.gameCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scroll
            shoot();
        }, {passive: false});
        
        ui.reloadBtn.addEventListener('click', reload);
        ui.upgradeBtn.addEventListener('click', upgradeWeapon);
        ui.grenadeBtn.addEventListener('click', throwGrenade);
        ui.claimBtn.addEventListener('click', claim);
        
        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') shoot();
            if (e.code === 'KeyR') reload();
            if (e.code === 'KeyG' || e.code === 'Digit3') throwGrenade(); // Grenade on G or 3
        });

        function throwGrenade() {
            if (!gameState.isPlaying) return;
            
            // Grenade Cost: Lowered to 30% of Bet
            const cost = Math.ceil(gameState.bet * 0.3);
            
            if (gameState.sessionCoins >= cost) {
                gameState.sessionCoins -= cost;
                playSound('explosion');
                
                // Damage all enemies
                enemies.forEach(e => {
                    e.hp -= 100; // Massive damage
                    createHitEffect(e.x, 250);
                    // Update HP bar
                    e.hpBar.style.width = Math.max(0, (e.hp / e.maxHp) * 100) + '%';
                    
                    if (e.hp <= 0) {
                        // Kill logic will be handled in next frame or we call it here?
                        // Better to let the game loop handle deaths, but we need to ensure they die properly.
                        // We can set HP to 0 and let the loop clean up, OR force cleanup.
                        // The loop checks (hp <= 0) inside collision logic.
                        // But here we are outside collision.
                        // So we should handle death rewards here.
                        
                        // BUT: to avoid code duplication, let's just ensure they are dead.
                        // We can mark them dead or trigger the reward function.
                        // Let's create a helper `killEnemy(index)`?
                        // Or just let the loop handle it? 
                        // The loop only checks collision. It doesn't check "is dead" generally unless hit by bullet.
                        // So we must handle death here.
                        
                        handleEnemyDeath(e);
                    }
                });
                
                // Remove dead enemies
                enemies = enemies.filter(e => e.hp > 0);
                
                // Visual effect
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.inset = '0';
                flash.style.background = 'white';
                flash.style.opacity = '0.8';
                flash.style.transition = 'opacity 0.5s';
                ui.gameCanvas.appendChild(flash);
                setTimeout(() => flash.style.opacity = '0', 50);
                setTimeout(() => flash.remove(), 550);
                
                updateUI();
            } else {
                ui.grenadeBtn.classList.add('shake');
                setTimeout(() => ui.grenadeBtn.classList.remove('shake'), 500);
            }
        }
        
        function handleEnemyDeath(e) {
             e.element.remove();
             
             // Reward Logic (Lowered)
             let baseReward = Math.ceil(gameState.bet * 0.1); // Lowered from 0.12
             
             if (gameState.volatility > 0.8) baseReward = Math.ceil(baseReward * 1.3); // Lowered multiplier
             
             const luck = Math.random();
             let multiplier = 1;
             
             // Lowered chances
             if (luck > 0.99) { // Was 0.98
                 multiplier = 5; // Was 10
                 showFloatingText('JACKPOT! x5', e.x, 150);
             } else if (luck > 0.95) { // Was 0.90
                 multiplier = 2; // Was 3
                 showFloatingText('BIG WIN! x2', e.x, 150);
             }
             
             const reward = (baseReward * multiplier);
             gameState.sessionCoins += reward;
             showFloatingText(`+${reward}üí∞`, e.x, 200);
             
             gameState.enemiesKilled++;
             if (gameState.enemiesKilled % 5 === 0) {
                 gameState.wave++;
                 showFloatingText(`WAVE ${gameState.wave}!`, ui.gameCanvas.offsetWidth/2, 100);
             }
        }

    </script>
</body>
</html>
